from typing import Tuple, List, Iterator, Dict, Union, Optional
from torch import Tensor
from argparse import Namespace
from numpy.typing import NDArray

from abc import ABC, abstractmethod


class AbstractInputEncoder(ABC):
    """
    Input encoding base class

    Input encoders take in data of a standardized format and prepare them for
    consumption by a model.
    """
    def __init__(self, config: Namespace) -> None:
        self._input_dim: Optional[Tuple[int, ...]] = None
        super().__init__()

    @abstractmethod
    def fit(self, inputs: Iterator[List[Tuple[int, NDArray]]]) -> None:
        """
        Fit the input encoder to the train data

        Mainly required for calculating normalization statistics across the
        train set. Should always set self._input_dim - failing to do so will
        raise an error when attempting to build a model

        :param inputs Iterator[List[Tuple[int, NDArray]]]: Generator iterating
        over entire train split, as loaded by the designated Loader
        """
        pass

    @abstractmethod
    def transform(self, data: List[Tuple[int, NDArray]], is_train: bool) -> Tensor:
        """
        Transform the data into a format the model can consume

        :param data List[Tuple[int, NDArray]]: Single datapoint from a Loader
        :param is_train bool: Whether the datapoint is in the train set or not
        :rtype Tensor: Transformed data
        """
        pass

    @abstractmethod
    def collate_fn(
        self, batch: List[Dict[str, Union[Tensor, int]]]
    ) -> Dict[str, Tensor]:
        """
        Collate function to use for batching

        See PyTorch documentation on Datasets for further details:
        https://pytorch.org/docs/stable/data.html

        :param batch List[Dict[str, Union[Tensor, int]]]: List of datapoints as
        generated by Dataset.__get_item__(). Datapoints are dictionaries with
        "input" and "target" keys, each mapping to a datapoint generated by
        Input Encoder and Target Encoder transform() methods
        :rtype Dict[str, Tensor]: Dictionary with "input" and "target" keys,
        corresponding to input and target tensors to feed into model
        """
        pass

    @property
    def input_dim(self) -> Tuple[int, ...]:
        if self._input_dim is None:
            raise NotImplementedError
        return self._input_dim
